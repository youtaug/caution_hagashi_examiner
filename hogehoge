import time
import sys
import argparse
import getpass
from datetime import datetime, timedelta, timezone
import traceback


sys.path.append("/content/drive/MyDrive/IT/colab_modules/")
import pandas as pd
from lime_sdk.errors import DakosRateLimitError, AdpalStatusFailedError
from lime_sdk.type import SearchCondition, Subject, Type, Status, TransferAllocation
from lime_sdk import Client, ICEClient

from google_drive_operations import (
    GoogleDriveOperations,
    google_drive_url_to_id,
)
from common_japanese import get_lime_password, get_2nd_fb_examiner_list
from slack_tools import Slack

pd.set_option("display.max_columns", 100)
pd.set_option("display.max_rows", 100)

JST = timezone(timedelta(hours=+9), "JST")
BOT_INFO_URL = "https://docs.google.com/spreadsheets/d/1C9C7Evvfv73HaU5M61QBXKVXbeGjeZM7m-_pkok8SZ0"
EXAMINER_LIST_TENSAKU_URL = "https://docs.google.com/spreadsheets/d/1iOFCqIM7n9M-5Fza8DeacxR-sWraKPTVxR-qOVMkZPg"
EXAMINER_LIST_SAITEN_URL = "https://docs.google.com/spreadsheets/d/1X5Owo7llgOjTtxfPMqHHLePHsVGH0uTi3UQM7fRJTgY"
DELAY_HAGASHI_RECORD_SHEET_URL = "https://docs.google.com/spreadsheets/d/1uR-t06V5q-pl4Ufi1bTsplSdh0ppi8YEDLDpwswO1YQ"
DELAY_FORM_URL = "https://docs.google.com/spreadsheets/d/1tF4yg4HLjKC2_t8NYNHnApL-0inMrwF4Ja7CWkESq0Y"
FURIWAKE_LOG_FOLDER = (
    "https://drive.google.com/drive/folders/1C3v6808xB5VsdZ8i93Hh2pCe7sNZOdAd"
)
MESSAGE_TEMPLATE_URL = "https://docs.google.com/spreadsheets/d/1-M022Mk7KrdxAKGa5KG6quF6aOnujOpmmqUI4-qqKLU/edit?gid=916632858#gid=916632858"
DEFECTIVE_ANSWERS_URL = "https://docs.google.com/spreadsheets/d/12H4Tp71qhbfmN9Bsz8BfvVALCdo-A1h9ukqY2J5BmxY/edit?gid=1453271592#gid=1453271592"
SPECIAL_EXAMINERS_URL = "https://docs.google.com/spreadsheets/d/1AgMolmpkFHg8z-J_NPp2BfyVrea5hyOnye5U39ScY3w/edit?gid=902606594#gid=902606594"
CONTACT_FORM_URL = "https://docs.google.com/spreadsheets/d/1dPw4PKNS1vhMUMTzyghifwgKO5K55a25l-XqzQAHrFY/edit?resourcekey=&gid=1542026582#gid=1542026582"
TEST_SPREAD_SHEET_URL = "https://docs.google.com/spreadsheets/d/1HwlaLI7TN7P3hETtrVtRbJkwvc2I9gN7_kzgwl_uHVQ/edit?pli=1&gid=81070433#gid=81070433"
FINAL_APPROACH_SPREAD_SHEET = "https://docs.google.com/spreadsheets/d/1ZH824KF4o7tqHhFX4Cy0UTjIGWCUUW8QoVk0jcAY3nU"
SLACK_TOKEN_LEADER = (
    "xoxp-576468181220-854959979253-1325064529862-4666c71e9c8e1e29694e5107561ff0d9"
)
SLACK_CH_ID_LEADER_NOTICE = "CM7349AB1"  # 朝剥がしand夜催促
SLACK_CH_ID_LEADER_BOT = "CKH8S7EM8"  # botからの連絡
SLACK_CH_ID_LEADER_TEST = "CLVB7PAAF"  # test
SLACK_CH_ID_LEADER_CLOSING = "CKDDR8ZFG"  # closing報告-質問
SLACK_TOKEN_TENSAKU = (
    "xoxp-832367029650-856488189046-1331788624146-c6d010818c1a8ba471eb8b5848fe6162"
)
SLACK_CH_ID_TENSAKU_TEST = "C06ED0625K9"  # 国語itテスト用
SLACK_TOKEN_SHIDAI = (
    "xoxp-5497258157847-5508865621525-6493586375782-f0477d889d6737410f69a62dec8993e0"
)
SLACK_CH_ID_SHIDAI_TEST = "C06E6DJ3V55"  # 国語itテスト用
SLACK_CH_ID_SHIDAI_NOTICE = "C05FWSW2B1T"  # 緊急答案共有
NO_COUNT_REASONS = {
    "2nd_fb": "新規FB待ち",
    "form": "問い合わせフォームでの対応待ち・問い合わせフォームで提出",
    "viking": "バイキング・緊急答案取得（遅延にはカウントされませんのでご安心ください）",
}
IT_MENTION_USER_ID = "U025LE63534"


class DeadlineAnswersManager:
    def __init__(
        self,
        user_id: str = "N0480551",
        password: str = "",
        is_colab: bool = False,
        is_test: bool = False,
        is_final_approach: bool = False,
        is_shidai_only: bool = False,
    ):
        self.is_colab = is_colab
        self.is_test = is_test
        self.is_final_approach = is_final_approach
        self.is_shidai_only = is_shidai_only  # 私大はFA関係ないので
        self.gdo = GoogleDriveOperations(is_colab=self.is_colab)
        self.user_id = user_id
        self.password = password
        if not self.is_colab:
            if password == "":
                print("LIMEへの接続情報を取得中...")
                self.password = get_lime_password(gdo=self.gdo)
        self.execute_time = datetime.now(JST)
        self.deadline_date = self.execute_time.replace(
            hour=20, minute=0, second=0, microsecond=0
        )
        if (
            self.execute_time.hour < 20
        ):  # 20~24時までは当日＝提出締切、0時以降は前日＝提出締切
            self.deadline_date -= timedelta(days=1)
        self.return_date = self.deadline_date + timedelta(days=1)
        if self.is_final_approach:
            # ファイナルアプローチの場合はスプシから対象の日付を取得
            final_approach_spread_sheet_id = google_drive_url_to_id(
                FINAL_APPROACH_SPREAD_SHEET
            )
            final_approach_spread_sheet_df = self.gdo.get_spread_sheet_as_df(
                sheet_id=final_approach_spread_sheet_id, sheet_name="日程"
            )
            deadline_date_str = self.deadline_date.strftime("%Y/%m/%d")
            target_deadline_df = final_approach_spread_sheet_df.query(
                f'提出期限 == "{deadline_date_str}"'
            )
            if target_deadline_df.empty:
                print(f"{deadline_date_str}期限の答案はFA対象ではありません")
                raise ValueError(
                    "ファイナルアプローチスプシに提出期限が見つかりませんでした"
                )
            # 最初の行と最後の行をそれぞれ取得
            first_row = target_deadline_df.iloc[0]
            last_row = target_deadline_df.iloc[-1]
            received_date_from = first_row["コンテンツ受付日"]
            received_date_to = last_row["コンテンツ受付日"]
            self.received_date_from = datetime.strptime(received_date_from, "%Y/%m/%d")
            self.received_date_to = datetime.strptime(received_date_to, "%Y/%m/%d")
            # fromとtoが正しい順番になっていない場合はエラーを出力
            if self.received_date_from > self.received_date_to:
                raise ValueError(
                    "ファイナルアプローチスプシのコンテンツ受付日の範囲が正しくありません"
                )
        else:
            # 振り分け日が2日前の答案が催促の対象
            # 例: 2024/01/01の振り分け日の答案は2024/01/03 20:00が提出締切
            self.received_date_from = self.deadline_date - timedelta(days=2)
            self.received_date_to = self.deadline_date - timedelta(days=2)
            # 時刻を0:00に設定
            self.received_date_from = self.received_date_from.replace(
                hour=0, minute=0, second=0, microsecond=0
            )
            self.received_date_to = self.received_date_to.replace(
                hour=0, minute=0, second=0, microsecond=0
            )
        bot_info_id = google_drive_url_to_id(BOT_INFO_URL)
        self.bot_info_examiner_df = self.gdo.get_spread_sheet_as_df(
            bot_info_id, sheet_name="examiners"
        )
        self.bot_info_leader_df = self.gdo.get_spread_sheet_as_df(
            bot_info_id, sheet_name="leaders"
        )
        self.bot_info_shidai_df = self.gdo.get_spread_sheet_as_df(
            bot_info_id, sheet_name="shidai_examiners"
        )

    def get_furiwake_log_df(self) -> pd.DataFrame:
        """2日前の振り分けログを取得してdfとして返す"""
        print("振り分けログを読み込みます")
        folder_id = google_drive_url_to_id(FURIWAKE_LOG_FOLDER)
        furiwake_date_from_str = self.received_date_from.strftime("%Y-%m-%d")
        furiwake_date_to_str = self.received_date_to.strftime("%Y-%m-%d")
        if furiwake_date_from_str != furiwake_date_to_str:
            furiwake_date_list = [furiwake_date_from_str, furiwake_date_to_str]
            furiwake_date_list.sort()
        else:
            furiwake_date_list = [furiwake_date_from_str]
        furiwake_log_df = pd.DataFrame()
        for furiwake_date_str in furiwake_date_list:
            file_search_keyword = (
                f"furiwake_log_{furiwake_date_str}.csv"  # 例: output-2024-01-01
            )
            files = self.gdo.search_files(
                folder_id=folder_id, name=file_search_keyword, mime_type="text/csv"
            )
            if not files:
                raise FileNotFoundError(
                    f"{furiwake_date_str}の振り分けログが見つかりませんでした"
                )
            file = files[0]
            file_name = file["name"]
            file_id = file["id"]
            df = self.gdo.get_csv_file_as_df(file_id, header=0)
            df["as_id"] = df["as_id"].astype(str)
            print(f"{file_name}を読み込みました")
            furiwake_log_df = pd.concat([furiwake_log_df, df], ignore_index=True)
        return furiwake_log_df

    def get_answer_info_df(self) -> pd.DataFrame:
        """LIMEから答案情報を検索し、点数が未入力の答案を抽出してdfとして返す"""
        print("答案情報を取得します")
        if not self.is_colab:
            lime_client = Client(self.user_id, self.password)
        else:
            try:
                lime_client = Client(self.user_id, self.password)
            except Exception as e:
                print(f"LIMEに接続できませんでした: {e}")
                is_failed = True
                retry_count = 0
                while is_failed:
                    retry_count += 1
                    print(
                        "ユーザーIDまたはパスワードが間違っている可能性があります。再度入力してください"
                    )
                    user_id = input("ユーザーIDを再入力してください: ")
                    password = getpass.getpass("パスワードを再入力してください: ")
                    try:
                        lime_client = Client(user_id, password)
                        is_failed = False
                    except Exception as e:
                        print(f"LIMEに接続できませんでした: {e}")
                        if retry_count > 3:
                            print("リトライ回数が上限に達しました")
                            print("プログラムを終了します")
                            exit()

        subject: Subject = Subject.JAPANESE
        status: Status = Status.CORRECTING
        # received_dateが受付日の未提出答案を検索
        # 1日ずつ検索する
        all_results = []
        days = (
            int((self.received_date_to - self.received_date_from) / timedelta(days=1))
            + 1
        )
        for day in range(days):
            received_date = self.received_date_from + timedelta(days=day)
            received_date_str = received_date.strftime("%Y/%m/%d")
            search_condition_kakomon = SearchCondition(
                subject=subject,
                status=status,
                type=Type.KAKOMON,
                rec_from=received_date_str,
                rec_to=received_date_str,
            )
            search_condition_tanja = SearchCondition(
                subject=subject,
                status=status,
                type=Type.TANGEN,
                rec_from=received_date_str,
                rec_to=received_date_str,
            )
            try:
                result_kakomon = lime_client.search_sheets([search_condition_kakomon])
                result_tanja = lime_client.search_sheets([search_condition_tanja])
            except (AdpalStatusFailedError, DakosRateLimitError, RuntimeError) as e:
                print(f"LIMEでの検索に失敗しました: {e}")
                result_kakomon = lime_client.search_sheets([search_condition_kakomon])
                result_tanja = lime_client.search_sheets([search_condition_tanja])
            except Exception as e:
                print(f"LIMEでの検索に失敗しました: {e}")
                tb = traceback.format_exc()
                print(tb)
                raise
            print(
                f"{received_date_str}の過去問演習{len(result_kakomon)}件、単ジャ演習{len(result_tanja)}件を取得しました"
            )
            all_results += result_kakomon + result_tanja
            time.sleep(1.5)
        print("答案情報を取得しました")
        print(f"検索結果数: {len(all_results)}")
        print("未提出答案を抽出します")
        all_results = [result.as_json() for result in all_results]
        search_result_df = pd.DataFrame(all_results)
        # marks（得点）が未入力の答案 ＝ 未提出答案 を抽出
        if search_result_df.empty:
            print("未提出答案はありません")
            return search_result_df
        search_result_df = search_result_df.query('marks == ""')
        # outlineが国公立二次から始まるものを除外
        search_result_df = search_result_df[
            ~search_result_df["outline"].str.contains("国公立二次")
        ]
        search_result_df.reset_index(drop=True, inplace=True)
        return search_result_df

    def get_delay_form_df(self) -> pd.DataFrame:
        """received_date以降の遅延報告フォームの回答を取得してdfとして返す"""
        print("遅延報告を取得します")
        delay_form_id = google_drive_url_to_id(DELAY_FORM_URL)
        delay_form_df = self.gdo.get_spread_sheet_as_df(
            sheet_id=delay_form_id, sheet_name="answer"
        )
        # タイムスタンプ列の文字列をdatetime型に変換
        delay_form_df["タイムスタンプ"] = pd.to_datetime(
            delay_form_df["タイムスタンプ"]
        )
        # タイムスタンプがreceived_date以降のものを抽出
        received_date_ts = pd.Timestamp(self.received_date_from).tz_localize(None)
        delay_form_df = delay_form_df.query(f'タイムスタンプ >= "{received_date_ts}"')
        return_date_str = self.return_date.strftime("%m-%d")
        # 3/1期限の場合、閏年でもないのに2/29と入力する添削者がいるので、2/29も含めないといけない
        if return_date_str == "03-01":
            delay_form_df = delay_form_df.query("返却日 == '02-29' | 返却日 == '03-01'")
        else:
            delay_form_df = delay_form_df.query(f"返却日 == '{return_date_str}'")
        delay_form_df.loc[:, "添削者ID・teamID"] = delay_form_df[
            "添削者ID・teamID"
        ].astype(str)
        delay_form_df.reset_index(drop=True, inplace=True)
        return delay_form_df

    def get_defective_answers_df(self) -> pd.DataFrame:
        """received_date以降の未着手の不備答案情報を取得してdfとして返す"""
        print("不備答案情報を取得します")
        defective_answers_id = google_drive_url_to_id(DEFECTIVE_ANSWERS_URL)
        defective_answers_workbook = self.gdo.get_spread_sheet_workbook(
            defective_answers_id
        )
        worksheets = defective_answers_workbook.worksheets()
        sheet_names = [sheet.title for sheet in worksheets]
        for sheet_name in sheet_names:
            if "フォームの回答" in sheet_name:
                defective_answers_df = self.gdo.get_spread_sheet_as_df(
                    defective_answers_id, sheet_name
                )
                break
        # 報告時間列の文字列をdatetime型に変換
        defective_answers_df["タイムスタンプ"] = pd.to_datetime(
            defective_answers_df["タイムスタンプ"]
        )
        # 報告時間がreceived_date以降のものを抽出
        received_date_ts = pd.Timestamp(self.received_date_from).tz_localize(None)
        defective_answers_df = defective_answers_df.query(
            f'タイムスタンプ >= "{received_date_ts}"'
        )
        for column in ["ASID①", "ASID②", "ASID③", "ASID④", "ASID⑤"]:
            defective_answers_df.loc[:, column] = defective_answers_df[column].astype(
                str
            )
        defective_answers_df.reset_index(drop=True, inplace=True)
        return defective_answers_df

    def get_contact_form_df(self) -> pd.DataFrame:
        """received_date以降の問い合わせフォーム情報を取得してdfとして返す"""
        print("問い合わせフォーム情報を取得します")
        contact_form_id = google_drive_url_to_id(CONTACT_FORM_URL)
        contact_form_workbook = self.gdo.get_spread_sheet_workbook(contact_form_id)
        worksheets = contact_form_workbook.worksheets()
        sheet_names = [sheet.title for sheet in worksheets]
        for sheet_name in sheet_names:
            if "フォームの回答" in sheet_name:
                contact_form_df = self.gdo.get_spread_sheet_as_df(
                    contact_form_id, sheet_name
                )
                break
        # タイムスタンプ列の文字列をdatetime型に変換
        contact_form_df["タイムスタンプ"] = pd.to_datetime(
            contact_form_df["タイムスタンプ"]
        )
        # タイムスタンプがreceived_date以降のものを抽出
        received_date_ts = pd.Timestamp(self.received_date_from).tz_localize(None)
        contact_form_df = contact_form_df.query(
            f'タイムスタンプ >= "{received_date_ts}"'
        )
        contact_form_df = contact_form_df.astype({"添削者ID": str})
        contact_form_df = contact_form_df.astype({"該当答案のASID": str})
        contact_form_df.reset_index(drop=True, inplace=True)
        return contact_form_df

    def classify_deadline_answers(self) -> pd.DataFrame:
        """遅延情報をdfに整理する"""
        print("遅延情報を整理します")
        # 遅延情報を記録するためのdfを初期化
        summary_df: pd.DataFrame = pd.DataFrame()
        # 振り分けログを取得
        furiwake_log_df = self.get_furiwake_log_df()
        time.sleep(1.5)
        # 遅延報告フォームの回答を取得
        delay_form_df = self.get_delay_form_df()
        time.sleep(1.5)
        # 不備答案フォームの回答を取得
        defective_answers_df = self.get_defective_answers_df()
        time.sleep(1.5)
        # 問い合わせフォームの回答を取得
        contact_form_df = self.get_contact_form_df()
        time.sleep(1.5)
        # 特別な添削者（バイキング、team894など）を取得（遅延判定から除外するため）
        special_examiners_id_list = self.get_special_examiners_id_list()
        time.sleep(1.5)
        # 2次FB未卒業添削者を取得
        second_fb_examiners = get_2nd_fb_examiner_list(colab=self.is_colab)
        # 答案検索は他のスプシの情報を取得後に行う（添削者への優しさ）
        answer_info_df = self.get_answer_info_df()
        if answer_info_df.empty:
            return summary_df
        # 不備答案フォームのdfからASIDのリストを取得
        defective_as_ids = self.get_defective_as_ids(defective_answers_df)
        # 代理アップロード依頼のASIDを取得
        upload_request_as_ids = self.get_upload_request_as_ids(contact_form_df)
        # 遅延している添削者番号を取得
        delay_examiner_list = self.get_delay_examiner_list(answer_info_df)

        # 遅延している添削者ごとに処理
        for examiner_id in delay_examiner_list:
            slack_token, slack_ch_id, user_id, user_type = self.get_slack_info(
                examiner_id
            )
            if self.is_final_approach:
                if user_type == "shidai":
                    continue
            if self.is_shidai_only:
                if user_type != "shidai":
                    continue
            # 添削者名を取得
            examiner_name = answer_info_df.query(f'examiner_id == "{examiner_id}"')[
                "examiner_name"
            ].values[0]
            # teamIDやN1の人は末尾にスペースが入る(多分limeの検索結果でも)ので除去した変数も用意
            # これがあるせいでリスト内包表記で処理しづらい…
            space_removed_examiner_id = examiner_id.replace(" ", "")
            # examiner_idから数字を抽出した変数も用意
            examiner_id_num = self.get_examiner_id_num(space_removed_examiner_id)

            # 遅延している答案情報を取得
            examiner_answer_info_df = answer_info_df.query(
                f'examiner_id == "{examiner_id}"'
            )
            # 遅延している答案のASIDを取得
            # 不備報告のある答案は除外
            examiners_as_ids = self.get_examiners_as_ids(
                examiner_answer_info_df, defective_as_ids
            )

            # 代理アップロード依頼のASIDを除外
            examiner_upload_request_as_ids = [
                as_id for as_id in examiners_as_ids if as_id in upload_request_as_ids
            ]
            examiners_as_ids = [
                as_id
                for as_id in examiners_as_ids
                if as_id not in upload_request_as_ids
            ]
            if len(examiner_upload_request_as_ids) > 0:
                as_type = "request"
                summary_df_request = self.make_summary_df(
                    as_ids=examiner_upload_request_as_ids,
                    examiner_id=space_removed_examiner_id,
                    examiner_name=examiner_name,
                    as_type=as_type,
                    is_no_count=True,
                )
                summary_df = pd.concat(
                    [summary_df, summary_df_request], ignore_index=True
                )

            if len(examiners_as_ids) == 0:
                # 遅延している答案がない場合は後の処理をスキップ
                continue

            # 各dfからexaminer_idに関する情報を抽出
            # 遅延報告フォームの回答を取得
            examiner_delay_form_df = delay_form_df.loc[
                delay_form_df["添削者ID・teamID"] == examiner_id_num
            ]
            # 振り分けログを取得
            examiner_furiwake_log_df = furiwake_log_df.query(
                f'examiner_id == "{examiner_id}"'
            )

            # バイキング取得答案と遅延答案のASIDをそれぞれ取得
            viking_as_ids, delay_as_ids = self.get_viking_and_delay_as_ids(
                examiner_furiwake_log_df, examiners_as_ids
            )

            # 遅延に関する様々な判定（ノーカウントかどうか、予定時刻が正しいかどうかなど）
            # 特殊IDの場合の処理
            if space_removed_examiner_id in special_examiners_id_list:
                as_type = "special"
                summary_df_sp = self.make_summary_df(
                    as_ids=examiners_as_ids,
                    examiner_id=space_removed_examiner_id,
                    examiner_name=examiner_name,
                    as_type=as_type,
                    is_no_count=True,
                )
                summary_df = pd.concat([summary_df, summary_df_sp], ignore_index=True)
                continue

            # 遅延報告フォームが未提出の場合の処理
            if examiner_delay_form_df.empty:
                if len(viking_as_ids) > 0:
                    # バイキング答案の処理
                    as_type = "viking"
                    summary_df_viking = self.make_summary_df(
                        as_ids=viking_as_ids,
                        examiner_id=space_removed_examiner_id,
                        examiner_name=examiner_name,
                        as_type=as_type,
                        is_no_count=True,
                    )
                    summary_df = pd.concat(
                        [summary_df, summary_df_viking], ignore_index=True
                    )
                if len(delay_as_ids) == 0:
                    # 遅延がない場合は後の処理をスキップ
                    continue
                # 遅延がある場合の処理
                as_type = "delay"
                summary_df_not_reported = self.make_summary_df(
                    as_ids=delay_as_ids,
                    examiner_id=space_removed_examiner_id,
                    examiner_name=examiner_name,
                    as_type=as_type,
                    is_no_count=False,
                )
                summary_df = pd.concat(
                    [summary_df, summary_df_not_reported], ignore_index=True
                )
                continue

            # 遅延報告フォームが提出されている場合の処理
            delay_reasons = examiner_delay_form_df["遅延理由を教えてください"].tolist()

            # バイキング答案の処理
            if len(viking_as_ids) > 0:
                as_type = "viking"
                if NO_COUNT_REASONS["viking"] in delay_reasons:
                    # 報告アリの場合
                    # 理由からバイキングを削除
                    delay_reasons = [
                        reason
                        for reason in delay_reasons
                        if reason != NO_COUNT_REASONS["viking"]
                    ]
                    # 最新の報告を取得
                    form_answer_row = examiner_delay_form_df.query(
                        f'遅延理由を教えてください == "{NO_COUNT_REASONS["viking"]}"'
                    ).iloc[-1]
                    submission_time = form_answer_row["アップロード予定時刻"]
                    summary_df_viking = self.make_summary_df(
                        as_ids=viking_as_ids,
                        examiner_id=space_removed_examiner_id,
                        examiner_name=examiner_name,
                        as_type=as_type,
                        is_no_count=True,
                        submission_time=submission_time,
                    )
                    summary_df = pd.concat(
                        [summary_df, summary_df_viking], ignore_index=True
                    )
                else:
                    # 報告ナシの場合
                    summary_df_viking = self.make_summary_df(
                        as_ids=viking_as_ids,
                        examiner_id=space_removed_examiner_id,
                        examiner_name=examiner_name,
                        as_type=as_type,
                        is_no_count=True,
                    )
                    summary_df = pd.concat(
                        [summary_df, summary_df_viking], ignore_index=True
                    )
            if len(delay_as_ids) == 0:
                # 遅延がない場合は後の処理をスキップ
                continue

            # 2次FB未卒業添削者の処理
            # 1回でも報告があれば所持答案はすべてノーカウント扱いにする
            if NO_COUNT_REASONS["2nd_fb"] in delay_reasons:
                delay_reasons = [
                    reason
                    for reason in delay_reasons
                    if reason != NO_COUNT_REASONS["2nd_fb"]
                ]
                if space_removed_examiner_id in second_fb_examiners:
                    pass
                else:
                    form_answer_row = examiner_delay_form_df.query(
                        f'遅延理由を教えてください == "{NO_COUNT_REASONS["2nd_fb"]}"'
                    ).iloc[-1]
                    submission_time = form_answer_row["アップロード予定時刻"]
                    as_type = "2nd_fb"
                    summary_df_2nd_fb = self.make_summary_df(
                        as_ids=delay_as_ids,
                        examiner_id=space_removed_examiner_id,
                        examiner_name=examiner_name,
                        as_type=as_type,
                        is_no_count=True,
                        submission_time=submission_time,
                    )
                    summary_df = pd.concat(
                        [summary_df, summary_df_2nd_fb], ignore_index=True
                    )
                    continue

            # 問い合わせフォームの処理
            if NO_COUNT_REASONS["form"] in delay_reasons:
                delay_reasons = [
                    reason
                    for reason in delay_reasons
                    if reason != NO_COUNT_REASONS["form"]
                ]
                # ↓ 虚偽申請を省くための処理。
                examiner_contact_form_df = contact_form_df.query(
                    f'添削者ID == "{examiner_id_num}"'
                )
                is_true_reason = True
                if examiner_contact_form_df.empty:
                    # 添削者番号で問い合わせフォームが見つからない場合は氏名で検索（入力間違いへの救済措置）
                    examiner_contact_form_df = contact_form_df.query(
                        f'`氏名(フルネーム)` == "{examiner_name.replace(" ", "")}"'
                    )
                    if examiner_contact_form_df.empty:
                        # 問い合わせフォームがない場合はpass
                        is_true_reason = False
                if is_true_reason:
                    # 虚偽申請でない場合の処理
                    # 所持答案のうち、問い合わせている答案のASIDを取得し、対象答案のみを遅延答案から除外
                    form_as_ids = []
                    for form_as_id in examiner_contact_form_df[
                        "該当答案のASID"
                    ].tolist():
                        form_as_ids.extend(form_as_id.split(" "))
                    form_as_ids = list(set(form_as_ids))
                    form_as_ids = [
                        as_id for as_id in form_as_ids if as_id in delay_as_ids
                    ]
                    # delay_as_idsからform_as_idsを除外
                    delay_as_ids = [
                        as_id for as_id in delay_as_ids if as_id not in form_as_ids
                    ]
                    if len(form_as_ids) > 0:
                        form_answer_row = examiner_delay_form_df.query(
                            f'遅延理由を教えてください == "{NO_COUNT_REASONS["form"]}"'
                        ).iloc[-1]
                        submission_time = form_answer_row["アップロード予定時刻"]
                        as_type = "form"
                        summary_df_form = self.make_summary_df(
                            as_ids=form_as_ids,
                            examiner_id=space_removed_examiner_id,
                            examiner_name=examiner_name,
                            as_type=as_type,
                            is_no_count=True,
                            submission_time=submission_time,
                        )
                        summary_df = pd.concat(
                            [summary_df, summary_df_form], ignore_index=True
                        )
                        if len(delay_as_ids) == 0:
                            # 遅延答案が問い合わせフォーム対応待ちのみの場合は後の処理をスキップ
                            continue

            # 振り分け答案を持っていて遅延理由がない場合は無断遅延扱いにする
            if len(delay_reasons) == 0:
                as_type = "delay"
                summary_df_not_reported = self.make_summary_df(
                    as_ids=delay_as_ids,
                    examiner_id=space_removed_examiner_id,
                    examiner_name=examiner_name,
                    as_type=as_type,
                    is_no_count=False,
                )
                summary_df = pd.concat(
                    [summary_df, summary_df_not_reported], ignore_index=True
                )
                continue

            # 遅延報告ありの場合の処理
            delay_reason = delay_reasons[-1]  # 最新の報告を取得
            form_answer_row = examiner_delay_form_df.query(
                f'遅延理由を教えてください == "{delay_reason}"'
            ).iloc[-1]
            submission_time = form_answer_row["アップロード予定時刻"]
            as_type = "delay"
            summary_df_reported = self.make_summary_df(
                as_ids=delay_as_ids,
                examiner_id=space_removed_examiner_id,
                examiner_name=examiner_name,
                as_type=as_type,
                is_no_count=False,
                submission_time=submission_time,
            )
            summary_df = pd.concat([summary_df, summary_df_reported], ignore_index=True)

        return summary_df

    def get_delay_examiner_list(self, answer_info_df: pd.DataFrame) -> list:
        """遅延している添削者番号のリストを取得して返す"""
        delay_examiner_list = answer_info_df["examiner_id"].tolist()
        # 昇順でソート
        delay_examiner_list = list(set(delay_examiner_list))
        delay_examiner_list.sort()
        return delay_examiner_list

    def get_special_examiners_id_list(self) -> list:
        """特別な添削者番号のリストを取得して返す"""
        special_examiners_ss_id = google_drive_url_to_id(SPECIAL_EXAMINERS_URL)
        special_examiners_df = self.gdo.get_spread_sheet_as_df(
            special_examiners_ss_id, sheet_name="剥がし催促"
        )
        special_examiners_id_list = special_examiners_df["添削者番号"].tolist()
        return special_examiners_id_list

    def get_defective_as_ids(self, defective_answers_df: pd.DataFrame) -> list:
        """不備答案のASIDのリストを取得して返す"""
        defective_asid_columns = ["ASID①", "ASID②", "ASID③", "ASID④", "ASID⑤"]
        defective_as_ids = []
        for col in defective_asid_columns:
            defective_as_ids.extend(defective_answers_df[col].tolist())
        defective_as_ids = [str(as_id) for as_id in defective_as_ids if as_id != ""]
        defective_as_ids = list(set(defective_as_ids))
        return defective_as_ids

    def get_examiners_as_ids(
        self, examiner_answer_info_df: pd.DataFrame, defective_as_ids: list
    ) -> list:
        """添削者の持っているASIDのリストを取得して返す"""
        as_ids = examiner_answer_info_df["as_id"].tolist()
        as_ids = list(set(as_ids))
        as_ids = [str(as_id) for as_id in as_ids if as_id not in defective_as_ids]
        # 昇順でソート
        as_ids.sort()
        return as_ids

    def get_upload_request_as_ids(self, contact_form_df: pd.DataFrame) -> list:
        """問い合わせフォームでのアップロード依頼のASIDのリストを取得して返す"""
        upload_request_df = contact_form_df.query(
            'ご相談内容 == "答案をアップロードできない"'
        )
        upload_request_df = pd.concat(
            [
                upload_request_df,
                contact_form_df.query('ご相談内容 == "復習の指針関連"'),
            ],
            ignore_index=True,
        )
        str_as_ids = upload_request_df["該当答案のASID"].tolist()
        upload_request_as_ids = []
        for str_as_id in str_as_ids:
            as_ids = str_as_id.split(" ")
            upload_request_as_ids.extend(as_ids)
        upload_request_as_ids = list(set(upload_request_as_ids))
        return upload_request_as_ids

    def make_summary_df(
        self,
        as_ids: list,
        examiner_id: str,
        examiner_name: str,
        as_type: str,
        is_no_count: bool,
        submission_time: str = "",
    ) -> pd.DataFrame:
        """処理結果のdfを作成して返す"""
        if submission_time == "":
            is_reported = False
        else:
            is_reported = True
        summary_dict = {
            "type": as_type,
            "id": examiner_id,
            "name": examiner_name,
            "as_ids": as_ids,
            "is_reported": is_reported,
            "submission_time": submission_time,
            "is_no_count": is_no_count,
        }
        summary_df = pd.DataFrame([summary_dict])
        return summary_df

    def get_examiner_id_num(self, space_removed_examiner_id: str) -> str:
        """examiner_idから数字を抽出して返す"""
        if space_removed_examiner_id.startswith("team"):
            examiner_id_num = space_removed_examiner_id.replace("team", "")
        elif space_removed_examiner_id.startswith("N5"):
            examiner_id_num = space_removed_examiner_id.replace("N5", "")
        elif space_removed_examiner_id.startswith("N0"):
            examiner_id_num = space_removed_examiner_id.replace("N0", "")
        elif space_removed_examiner_id.startswith("N"):
            examiner_id_num = space_removed_examiner_id.replace("N", "")
        else:
            examiner_id_num = space_removed_examiner_id
        return examiner_id_num

    def get_viking_and_delay_as_ids(
        self, examiner_furiwake_log_df: pd.DataFrame, examiners_as_ids: list
    ) -> tuple[list, list]:
        """バイキング答案と遅延答案のASIDのリストを取得して返す"""
        furiwake_log_as_ids = examiner_furiwake_log_df["as_id"].tolist()
        furiwake_log_as_ids = list(set(furiwake_log_as_ids))
        # 昇順でソート
        furiwake_log_as_ids.sort()
        # バイキング答案＝振り分けログにないが、答案検索の結果に存在している答案
        viking_as_ids = [
            str(as_id) for as_id in examiners_as_ids if as_id not in furiwake_log_as_ids
        ]
        # 遅延答案＝振り分けログにあり、かつ答案検索の結果にも存在している答案
        delay_as_ids = [
            str(as_id) for as_id in examiners_as_ids if as_id in furiwake_log_as_ids
        ]
        return viking_as_ids, delay_as_ids

    def manage_delay_answers(self):
        """遅延答案の情報を記録する"""
        deadline_answers_df = self.classify_deadline_answers()
        if deadline_answers_df.empty:
            print("遅延答案はありません")
            self.send_complete_report(deadline_answers_df, "夜催促")
            return
        delay_answers_df = deadline_answers_df.query('type == "delay"')
        self.record_delay_info(delay_answers_df)
        self.send_remind_message_to_examiner(deadline_answers_df)
        self.send_complete_report(deadline_answers_df, "夜催促")

    def manage_hagashi_answers(self, mode: str):
        """未提出答案の情報を記録する"""
        if self.is_final_approach and mode == "夜剥がし":
            raise ValueError("FA期間中の夜剥がしは行いません")
        deadline_answers_df = self.classify_deadline_answers()
        if deadline_answers_df.empty:
            print("未提出答案はありません")
            self.send_complete_report(deadline_answers_df, mode)
            return
        deadline_answers_df, is_over_threshold = self.move_answer_to_viking(
            deadline_answers_df=deadline_answers_df, mode=mode
        )
        hagashi_answer_df = deadline_answers_df.query('type == "hagashi"')
        shidai_hagashi_answer_df = deadline_answers_df.query('type == "shidai_hagashi"')
        total_hagashi_answer_df = pd.concat(
            [hagashi_answer_df, shidai_hagashi_answer_df], ignore_index=True
        )
        if not self.is_final_approach:
            self.record_hagashi_info(total_hagashi_answer_df)
            self.send_hagashi_message_to_examiner(total_hagashi_answer_df, mode)
        self.send_complete_report(deadline_answers_df, mode)
        if len(shidai_hagashi_answer_df) > 0:
            self.send_shidai_viking_notice_message(shidai_hagashi_answer_df)
        if self.is_final_approach or is_over_threshold:
            self.send_manual_hagashi_message(total_hagashi_answer_df)

    def record_delay_info(self, delay_answers_df: pd.DataFrame):
        """遅延答案の情報を記録する"""
        print("遅延答案の情報を記録します")
        record_df = pd.DataFrame()
        detailed_record_df = pd.DataFrame()
        for i, row in delay_answers_df.iterrows():
            examiner_id = row["id"]
            examiner_name = row["name"]
            as_ids = row["as_ids"]
            num_of_as_ids = len(as_ids)
            as_ids_str = ", ".join(as_ids)
            is_reported = row["is_reported"]
            if is_reported:
                is_reported_str = "TRUE"
            else:
                is_reported_str = "FALSE"
            submission_time = row["submission_time"]
            if submission_time == "":
                submission_time = "無断"
            is_no_count = row["is_no_count"]
            if is_no_count:
                is_no_count_str = "TRUE"
            else:
                is_no_count_str = "FALSE"
            return_date = self.return_date.strftime("%Y-%m-%d")
            update_time = self.execute_time.strftime("%Y/%m/%d %H:%M:%S")
            record_dict = {
                "UPDATE_TIME": update_time,
                "ID": examiner_id,
                "NAME": examiner_name,
                "KENSU": num_of_as_ids,
                "RETURN_DATE": return_date,
                "ADVANCE_REPORT": is_reported_str,
                "SUBMISSION_TIME": submission_time,
                "NO_COUNT": is_no_count_str,
            }
            record_df = pd.concat(
                [record_df, pd.DataFrame([record_dict])], ignore_index=True
            )
            detailed_record_dict = {
                "UPDATE_TIME": update_time,
                "ID": examiner_id,
                "NAME": examiner_name,
                "AS_ID": as_ids_str,
                "RETURN_DATE": return_date,
                "ADVANCE_REPORT": is_reported_str,
                "SUBMISSION_TIME": submission_time,
                "NO_COUNT": is_no_count_str,
            }
            detailed_record_df = pd.concat(
                [detailed_record_df, pd.DataFrame([detailed_record_dict])],
                ignore_index=True,
            )
        # dfをスプレッドシートに書き込む
        # スプシに元々あるデータを読み込む
        delay_record_id = google_drive_url_to_id(DELAY_HAGASHI_RECORD_SHEET_URL)
        delay_record_df = self.gdo.get_spread_sheet_as_df(
            delay_record_id, sheet_name="record"
        )
        detailed_delay_record_df = self.gdo.get_spread_sheet_as_df(
            delay_record_id, sheet_name="detailed_record"
        )
        # データを追加して書き込む
        delay_record_df = pd.concat([delay_record_df, record_df], ignore_index=True)
        detailed_delay_record_df = pd.concat(
            [detailed_delay_record_df, detailed_record_df], ignore_index=True
        )
        if self.is_test:
            delay_record_id = google_drive_url_to_id(TEST_SPREAD_SHEET_URL)
        self.gdo.update_spread_sheet(
            sheet_id=delay_record_id,
            sheet_name="record",
            df=delay_record_df,
            overwrites=True,
        )
        time.sleep(15)
        self.gdo.update_spread_sheet(
            sheet_id=delay_record_id,
            sheet_name="detailed_record",
            df=detailed_delay_record_df,
            overwrites=True,
        )

    def record_hagashi_info(self, hagashi_answer_df: pd.DataFrame):
        """剥がした答案の情報を記録する"""
        print("剥がした答案の情報を記録します")
        record_df = pd.DataFrame()
        for i, row in hagashi_answer_df.iterrows():
            examiner_id = row["id"]
            examiner_name = row["name"]
            as_ids = row["as_ids"]
            for as_id in as_ids:
                return_date = self.return_date.strftime("%Y-%m-%d")
                received_date = self.received_date_from.strftime("%Y-%m-%d")
                if self.received_date_to - self.received_date_from > timedelta(days=0):
                    # 受付日が複数日にまたがる場合は受付日の空白にする
                    received_date = ""
                update_time = self.execute_time.strftime("%Y/%m/%d %H:%M:%S")
                record_dict = {
                    "UPDATE_TIME": update_time,
                    "ID": examiner_id,
                    "name": examiner_name,
                    "ASID": as_id,
                    "生徒番号/氏名": "",
                    "状態": "",
                    "種別": "",
                    "校舎番号/校舎名": "",
                    "概要": "",
                    "校舎受付日": "",
                    "コンテンツ受付日": received_date,
                    "返却予定日": return_date,
                }
                record_df = pd.concat(
                    [record_df, pd.DataFrame([record_dict])], ignore_index=True
                )
        # dfをスプレッドシートに書き込む
        # スプシに元々あるデータを読み込む
        hagashi_record_id = google_drive_url_to_id(DELAY_HAGASHI_RECORD_SHEET_URL)
        hagashi_record_df = self.gdo.get_spread_sheet_as_df(
            hagashi_record_id, sheet_name="hagashi"
        )
        # データを追加して書き込む
        hagashi_record_df = pd.concat([hagashi_record_df, record_df], ignore_index=True)
        if self.is_test:
            hagashi_record_id = google_drive_url_to_id(TEST_SPREAD_SHEET_URL)
        self.gdo.update_spread_sheet(
            sheet_id=hagashi_record_id,
            sheet_name="hagashi",
            df=hagashi_record_df,
            overwrites=True,
        )

    def send_remind_message_to_examiner(self, deadline_answers_df: pd.DataFrame):
        # 判定結果で送信文面を変更する
        message_template_df = self.get_message_template_df()
        examiner_ids = deadline_answers_df["id"].tolist()
        examiner_ids = list(set(examiner_ids))
        for examiner_id in examiner_ids:
            examiner_df = deadline_answers_df.query(f'id == "{examiner_id}"')
            examiner_name = examiner_df["name"].values[0]
            as_types = examiner_df["type"].tolist()
            # 送信しない条件を満たす場合はスキップ
            if "special" in as_types:
                as_types.remove("special")
                continue
            if "2nd_fb" in as_types:
                as_types.remove("2nd_fb")
                continue
            if "form" in as_types:
                as_types.remove("form")
            if "request" in as_types:
                as_types.remove("request")
            # 以下送信する場合の処理
            # Slackの設定
            slack_token, slack_ch_id, user_id, user_type = self.get_slack_info(
                examiner_id
            )
            if self.is_test or user_type == "unknown":
                mention = f"{examiner_id} {examiner_name}"
            else:
                mention = f"<@{user_id}>"
            # メッセージの種類を判定してメッセージを作成
            return_date = self.return_date.strftime("%m月%d日")
            if len(as_types) == 1 and "viking" in as_types:
                if user_type == "leader":
                    continue
                message_template = message_template_df[
                    message_template_df["種別"] == "バイキングのみ所持"
                ]["テンプレート"].values[0]
                num_of_answers = len(examiner_df["as_ids"].values[0])
                as_ids = ", ".join(examiner_df["as_ids"].values[0])
                message_text = message_template.format(
                    mention=mention,
                    num_of_answers=num_of_answers,
                    as_ids=as_ids,
                    return_date=return_date,
                )
                if self.is_test:
                    print(message_text)
                # Slackにメッセージを送信
                slack = Slack(slack_token)
                slack.chat_postMessage(channel=slack_ch_id, text=message_text)
                time.sleep(1.0)
            elif "delay" in as_types:
                # 以下遅延答案がある場合の処理
                # 遅延答案がある場合のテンプレートを取得
                examiner_delay_series = examiner_df.query('type == "delay"').iloc[0]
                is_reported = examiner_delay_series["is_reported"]
                submission_time = examiner_delay_series["submission_time"]

                def _is_correct_submission_time(submission_time_str: str) -> bool:
                    if submission_time_str == "無断":
                        return False
                    else:
                        # 報告ありの場合は提出期限+12時間
                        reported_deadline_time = self.deadline_date + timedelta(
                            hours=12
                        )
                        # submission_timeをdatetime型に変換
                        year = self.received_date_from.year
                        scheduled_date_str = submission_time_str.split(" ")[0]
                        scheduled_month_str = scheduled_date_str.split("/")[0]
                        if (
                            self.received_date_from.month == 12
                            and scheduled_month_str == "01"
                        ):
                            year += 1
                        try:
                            scheduled_date = datetime.strptime(
                                f"{year}/{submission_time_str}", "%Y/%m/%d %H:%M"
                            )
                        except ValueError:
                            if scheduled_date_str == "02/29":
                                # 閏年かどうかを確認する。絶対に毎年間違える愚か者がいるので。
                                scheduled_date = datetime.strptime(
                                    f"{year}/02/28", "%Y/%m/%d %H:%M"
                                )
                            else:
                                return False
                        # タイムゾーン情報を追加
                        scheduled_date = scheduled_date.replace(tzinfo=JST)
                        if scheduled_date > reported_deadline_time:
                            # 提出期限を過ぎている場合はFalse
                            return False
                        else:
                            return True

                is_correct_submission_time = _is_correct_submission_time(
                    submission_time
                )
                template_type = "夜催促"
                if self.is_final_approach:
                    pass
                else:
                    if is_reported:
                        template_type += "_報告あり"
                        if user_type == "leader":
                            template_type += "_リーダー"
                        elif not is_correct_submission_time:
                            template_type += "_時刻間違い"
                    else:
                        template_type += "_報告なし"
                        if user_type == "leader":
                            template_type += "_リーダー"
                        elif user_type == "shidai":
                            template_type += "_私大"

                message_template = message_template_df[
                    message_template_df["種別"] == template_type
                ]["テンプレート"].values[0]
                if "viking" in as_types:
                    viking_num = len(
                        examiner_df.query('type == "viking"')["as_ids"].values[0]
                    )
                    viking_as_ids = ", ".join(
                        examiner_df.query('type == "viking"')["as_ids"].values[0]
                    )
                    viking_message_template = message_template_df[
                        message_template_df["種別"] == "バイキング所持"
                    ]["テンプレート"].values[0]
                    viking_message_text = viking_message_template.format(
                        return_date=return_date,
                        num_of_answers=viking_num,
                        as_ids=viking_as_ids,
                    )
                else:
                    viking_message_text = ""
                num_of_answers = len(
                    examiner_df.query('type == "delay"')["as_ids"].values[0]
                )
                as_ids = ", ".join(
                    examiner_df.query('type == "delay"')["as_ids"].values[0]
                )
                message_text = message_template.format(
                    mention=mention,
                    return_date=return_date,
                    num_of_answers=num_of_answers,
                    scheduled_time=submission_time,
                    as_ids=as_ids,
                    viking=viking_message_text,
                )
                if self.is_test:
                    print(message_text)
                # Slackにメッセージを送信
                slack = Slack(slack_token)
                slack.chat_postMessage(channel=slack_ch_id, text=message_text)
                time.sleep(1.0)

    def send_hagashi_message_to_examiner(
        self, total_hagashi_answers_df: pd.DataFrame, mode: str
    ):
        message_template_df = self.get_message_template_df()
        examiner_ids = total_hagashi_answers_df["id"].tolist()
        examiner_ids = list(set(examiner_ids))
        for examiner_id in examiner_ids:
            as_ids = total_hagashi_answers_df.query(f'id == "{examiner_id}"')[
                "as_ids"
            ].values[0]
            as_ids = [str(as_id) for as_id in as_ids]
            as_ids_str = ", ".join(as_ids)
            examiner_name = total_hagashi_answers_df.query(f'id == "{examiner_id}"')[
                "name"
            ].values[0]
            as_type = total_hagashi_answers_df.query(f'id == "{examiner_id}"')[
                "type"
            ].values[0]
            # Slackの設定
            slack_token, slack_ch_id, user_id, user_type = self.get_slack_info(
                examiner_id
            )
            if self.is_test or user_type == "unknown":
                mention = f"{examiner_id} {examiner_name}"
            else:
                mention = f"<@{user_id}>"
            # メッセージの種類を判定してメッセージを作成
            return_date = self.return_date.strftime("%m月%d日")
            template_type = mode
            if as_type == "shidai_hagashi":
                template_type = mode + "_私大"
            message_template = message_template_df[
                message_template_df["種別"] == template_type
            ]["テンプレート"].values[0]
            message_text = message_template.format(
                mention=mention,
                as_ids=as_ids_str,
                return_date=return_date,
                num_of_answers=len(as_ids),
            )
            if self.is_test:
                print(message_text)
            # Slackにメッセージを送信
            slack = Slack(slack_token)
            slack.chat_postMessage(channel=slack_ch_id, text=message_text)
            time.sleep(1.0)

    def get_slack_info(self, examiner_id: str):
        examiner_id = examiner_id.replace(" ", "")
        user_type = "unknown"
        # リーダー → 添削者 → 私大採点者の順で探索
        bot_info_df = self.bot_info_leader_df.query(f'ID == "{examiner_id}"')
        if not bot_info_df.empty:
            user_type = "leader"
            slack_token = SLACK_TOKEN_LEADER
            if self.is_test:
                slack_ch_id = SLACK_CH_ID_LEADER_TEST
            else:
                slack_ch_id = SLACK_CH_ID_LEADER_BOT
        else:
            bot_info_df = self.bot_info_examiner_df.query(f'ID == "{examiner_id}"')
            if not bot_info_df.empty:
                user_type = "examiner"
                slack_token = SLACK_TOKEN_TENSAKU
                if self.is_test:
                    slack_ch_id = SLACK_CH_ID_TENSAKU_TEST
                else:
                    slack_ch_id = bot_info_df["channel_ID"].values[-1]
            else:
                bot_info_df = self.bot_info_shidai_df.query(f'ID == "{examiner_id}"')
                if not bot_info_df.empty:
                    user_type = "shidai"
                    slack_token = SLACK_TOKEN_SHIDAI
                    if self.is_test:
                        slack_ch_id = SLACK_CH_ID_SHIDAI_TEST
                    else:
                        slack_ch_id = bot_info_df["channel_ID"].values[-1]
        if user_type == "unknown":
            # 不明な場合はとりあえずtestチャンネルに送信する
            print(f"{examiner_id}のユーザータイプが不明です")
            slack_token = SLACK_TOKEN_LEADER
            slack_ch_id = SLACK_CH_ID_LEADER_TEST
            user_id = ""
        else:
            user_id = bot_info_df["user_ID"].values[-1]
        return slack_token, slack_ch_id, user_id, user_type

    def get_message_template_df(self, sheet_name: str = "遅延剥がし用") -> pd.DataFrame:
        """メッセージテンプレートを取得してdfとして返す"""
        print("メッセージテンプレートを取得します")
        if self.is_final_approach:
            message_template_id = google_drive_url_to_id(FINAL_APPROACH_SPREAD_SHEET)
            message_template_df = self.gdo.get_spread_sheet_as_df(
                message_template_id, sheet_name="剥がし催促文面"
            )
        else:
            message_template_id = google_drive_url_to_id(MESSAGE_TEMPLATE_URL)
            message_template_df = self.gdo.get_spread_sheet_as_df(
                message_template_id, sheet_name=sheet_name
            )
        return message_template_df

    def move_answer_to_viking(self, deadline_answers_df: pd.DataFrame, mode: str):
        """遅延答案をバイキングに移動する"""

        def send_error_message(message: str):
            """エラーメッセージを送信する"""
            slack_token = SLACK_TOKEN_LEADER
            slack_ch_id = SLACK_CH_ID_LEADER_TEST
            mention = f"<@{IT_MENTION_USER_ID}>"
            message = f"{mention}\n{message}"
            slack = Slack(slack_token)
            slack.chat_postMessage(channel=slack_ch_id, text=message)
            time.sleep(1.0)

        print("遅延答案をバイキングに移動します")
        delay_answers_df = deadline_answers_df.query('type == "delay"')
        if mode == "夜剥がし":
            delay_answers_df = delay_answers_df.query("is_reported == False")
        hagashi_examiner_ids = delay_answers_df["id"].tolist()
        hagashi_df: pd.DataFrame = pd.DataFrame()
        error_df: pd.DataFrame = pd.DataFrame()
        not_hagashi_as_ids = []
        # 実行前に剥がし答案の枚数だけ確認する
        num_of_hagashi_as = 0
        for examiner_id in hagashi_examiner_ids:
            slack_token, slack_ch_id, user_id, examiner_type = self.get_slack_info(
                examiner_id
            )
            if examiner_type == "leader":
                continue
            examiner_series = delay_answers_df.query(f'id == "{examiner_id}"').iloc[0]
            delay_as_ids = examiner_series["as_ids"]
            delay_as_ids = [str(as_id) for as_id in delay_as_ids]
            num_of_hagashi_as += len(delay_as_ids)
        if num_of_hagashi_as > 35:
            # 答案移動が1枚50秒として、すべてが点数未入力答案だった場合（答案移動が2回）に処理時間が1時間を超える枚数を閾値とする
            # num_of_hagashi_as * 50 * 2 / 60 > 60 → num_of_hagashi_as > 35
            if not self.is_final_approach:
                # FA期間中は自動剥がしを行わない
                print(
                    "剥がし答案の枚数が規定値を超えました。手動で答案を剥がしてください"
                )
                send_error_message(
                    "剥がし答案の枚数が規定値を超えました。手動で答案を剥がしてください"
                )
            is_over_threshold = True
        else:
            is_over_threshold = False
        for examiner_id in hagashi_examiner_ids:
            lime_client = Client(self.user_id, self.password)  # 401 Unauthorized対策
            error_as_ids = []
            # 添削者の情報を取得
            slack_token, slack_ch_id, user_id, examiner_type = self.get_slack_info(
                examiner_id
            )
            # 元となったdeadline_answers_dfから添削者の行を削除（後でdelay_answer_dfと連結させる方式で情報を更新するため）
            deadline_answers_df = deadline_answers_df.query(
                'type != "delay" or id != @examiner_id'
            )
            if examiner_type == "leader":  # リーダーは剥がし免除！
                continue
            examiner_series = delay_answers_df.query(f'id == "{examiner_id}"').iloc[
                0
            ]  # 添削者一人につき1行のみのはず
            delay_as_ids = examiner_series["as_ids"]
            delay_as_ids = [str(as_id) for as_id in delay_as_ids]
            if self.is_test:
                print(
                    f"本番では{examiner_id}の遅延答案をバイキングに移動します。テスト実行なのでスキップします"
                )
            elif self.is_final_approach:
                print(
                    "FA期間中は剥がし対象答案が大量に存在することが見込まれるため、剥がしを行いません。"
                )
            elif is_over_threshold:
                # 1時間を超える枚数の場合は手動で剥がしてもらう
                print("剥がし答案の枚数が規定値を超えました。自動剥がしを行いません")
            else:
                for as_id in delay_as_ids:
                    # もう一度答案の情報を取得
                    # 剥がし速度が遅すぎる(1枚50秒)ので、毎回得点が入力済みか否かは確認しなければならない
                    search_condition = SearchCondition(
                        as_id=as_id,
                        examiner_id=examiner_id,
                        rec_from=self.received_date_from.strftime("%Y/%m/%d"),
                        rec_to=self.received_date_to.strftime("%Y/%m/%d"),
                        subject=Subject.JAPANESE,
                        status=Status.CORRECTING,
                    )
                    lime_client = Client(
                        self.user_id, self.password
                    )  # 401 Unauthorized対策
                    try:
                        search_result = lime_client.search_sheets([search_condition])
                        search_result = search_result[0]
                        marks = search_result.marks
                        if marks != "":
                            not_hagashi_as_ids.append(as_id)
                            continue
                    except Exception:
                        pass
                    if self.is_final_approach:  # 到達不可能。剥がし答案の見込みが甘かった頃の名残
                        # user_typeがshidaiの場合はteam774に移動
                        # user_typeがexaminerの場合はVIKINGに移動
                        if examiner_type == "shidai":
                            allocations = [
                                TransferAllocation(
                                    as_id=as_id, examiner_id=examiner_id
                                ),
                                TransferAllocation(as_id=as_id, examiner_id="team774"),
                            ]
                        elif examiner_type == "examiner":
                            allocations = [
                                TransferAllocation(
                                    as_id=as_id, examiner_id=examiner_id
                                ),
                                TransferAllocation(as_id=as_id, examiner_id="VIKING"),
                            ]
                    else:
                        # 一旦全部team774に移動 → ICEClientで点数未入力判定を行う
                        # この処理をやめて剥がし上限枚数を上げても良いかもしれない
                        allocations = [
                            TransferAllocation(as_id=as_id, examiner_id=examiner_id),
                            TransferAllocation(as_id=as_id, examiner_id="team774"),
                        ]
                    try:
                        transfer_result = lime_client.transfer_sheets(allocations)
                    except Exception:
                        print(f"ASID: {as_id}の移動に失敗しました。再試行します")
                        lime_client = Client(
                            self.user_id, self.password
                        )  # 401 Unauthorized対策
                        try:
                            transfer_result = lime_client.transfer_sheets(allocations)
                        except Exception:
                            print(f"ASID: {as_id}の移動に失敗しました")
                            error_as_ids.append(as_id)
                            continue
                    if not transfer_result[0].transferred:
                        print(f"ASID: {as_id}の移動に失敗しました")
                        error_as_ids.append(as_id)
                        continue
                    hagashi_df = pd.concat(
                        [
                            hagashi_df,
                            pd.DataFrame(
                                [
                                    {
                                        "as_id": as_id,
                                        "examiner_id": examiner_id,
                                        "examiner_type": examiner_type,
                                    }
                                ]
                            ),
                        ],
                        ignore_index=True,
                    )
            # delay_answers_dfのtypeをhagashiに変更。私大の場合はshidai_hagashiに変更
            if examiner_type == "shidai":
                delay_answers_df.loc[delay_answers_df["id"] == examiner_id, "type"] = (
                    "shidai_hagashi"
                )
            else:
                delay_answers_df.loc[delay_answers_df["id"] == examiner_id, "type"] = (
                    "hagashi"
                )
            # もしerror_as_idsがあればdelay_answers_dfのas_idsリストから削除
            if len(error_as_ids) > 0:
                delay_answers_df.loc[
                    delay_answers_df["id"] == examiner_id, "as_ids"
                ] = [as_id for as_id in delay_as_ids if as_id not in error_as_ids]
                # error_as_idsがある場合、typeをerror、idがexaminer_idの行を追加
                error_dict = {
                    "type": "error",
                    "id": examiner_id,
                    "name": examiner_series["name"].values[0],
                    "as_ids": error_as_ids,
                    "is_reported": False,
                    "submission_time": "",
                    "is_no_count": False,
                }
                error_df = pd.concat(
                    [error_df, pd.DataFrame([error_dict])], ignore_index=True
                )
            if len(not_hagashi_as_ids) > 0:
                delay_answers_df.loc[
                    delay_answers_df["id"] == examiner_id, "as_ids"
                ] = [as_id for as_id in delay_as_ids if as_id not in not_hagashi_as_ids]
        if self.is_test or is_over_threshold or self.is_final_approach:
            # テスト実行中、剥がし上限枚数を超えた場合、FA期間中は剥がしを行わない場合はここで終了
            deadline_answers_df = pd.concat(
                [deadline_answers_df, delay_answers_df], ignore_index=True
            )
            return deadline_answers_df, is_over_threshold
        # ICEClientで点数未入力判定を行う
        ice_client = ICEClient(
            "team774", "12345678"
        )  # team774のICEアカウントで点数未入力判定を行う
        try:
            empty_as_ids = ice_client.mathapi().get(
                "as_id"
            )# 返り値はdictなのでPylance等のエラーは無視でOK(lime_sdk v2.0.0時点)
        except Exception:
            empty_as_ids = []
        if not hagashi_df.empty and len(empty_as_ids) > 0:  # 点数未入力の答案がある場合
            empty_as_ids = [str(as_id) for as_id in empty_as_ids]
            # hagashi_dfからempty_as_idsを削除
            hagashi_df = hagashi_df.query("as_id not in @empty_as_ids")
            hagashi_examiner_ids = hagashi_df["examiner_id"].tolist()
            hagashi_examiner_ids = list(set(hagashi_examiner_ids))
            for examiner_id in hagashi_examiner_ids:
                lime_client = Client(
                    self.user_id, self.password
                )  # 401 Unauthorized対策
                examiner_series = delay_answers_df.query(f'id == "{examiner_id}"').iloc[
                    0
                ]
                hagashi_as_ids = examiner_series["as_ids"]
                hagashi_as_ids = [str(as_id) for as_id in hagashi_as_ids]
                hagashi_as_ids = [
                    as_id for as_id in hagashi_as_ids if as_id not in empty_as_ids
                ]
                examiner_empty_as_ids = [
                    as_id for as_id in hagashi_as_ids if as_id in empty_as_ids
                ]
                if len(examiner_empty_as_ids) > 0:
                    # 点数未入力の答案がある場合、team774から添削者に移動
                    for as_id in examiner_empty_as_ids:
                        allocations = [
                            TransferAllocation(as_id=as_id, examiner_id="team774"),
                            TransferAllocation(as_id=as_id, examiner_id=examiner_id),
                        ]
                        try:
                            transfer_result = lime_client.transfer_sheets(allocations)
                        except Exception:
                            print(f"ASID: {as_id}の移動に失敗しました。再試行します")
                            lime_client = Client(
                                self.user_id, self.password
                            )  # 401 Unauthorized対策
                            try:
                                transfer_result = lime_client.transfer_sheets(
                                    allocations
                                )
                            except Exception:
                                print(f"ASID: {as_id}の移動に失敗しました")
                                message = f"{examiner_id}の点数未入力答案の差し戻しに失敗しました。ASID: {as_id}"
                                send_error_message(message)
                                continue
                        if not transfer_result[0].transferred:
                            print(f"ASID: {as_id}の移動に失敗しました")
                            # 失敗したら即座にslackに通知
                            message = f"{examiner_id}の点数未入力答案の差し戻しに失敗しました。ASID: {as_id}"
                            send_error_message(message)
                            continue
                    # delay_answers_dfのas_idsリストからempty_as_idsを削除
                    delay_answers_df.loc[
                        delay_answers_df["id"] == examiner_id, "as_ids"
                    ] = hagashi_as_ids
                    # typeをemptyに変更し、新しくdelay_answers_dfに追加
                    empty_dict = {
                        "type": "empty",
                        "id": examiner_id,
                        "name": examiner_series["name"].values[0],
                        "as_ids": examiner_empty_as_ids,
                        "is_reported": False,
                        "submission_time": "",
                        "is_no_count": False,
                    }
                    delay_answers_df = pd.concat(
                        [delay_answers_df, pd.DataFrame([empty_dict])],
                        ignore_index=True,
                    )
        if hagashi_df.empty:
            pass
        else:
            hagashi_as_ids = hagashi_df["as_id"].tolist()
            hagashi_as_ids = list(set(hagashi_as_ids))
            # team774に移動した答案をvikingに移動する(私大はteam774のまま)
            for hagashi_as_id in hagashi_as_ids:
                # examiner_typeがexaminerの場合はteam774からvikingに移動
                examiner_type = hagashi_df.query(f'as_id == "{hagashi_as_id}"')[
                    "examiner_type"
                ].values[0]
                if examiner_type == "examiner":
                    allocations = [
                        TransferAllocation(as_id=hagashi_as_id, examiner_id="team774"),
                        TransferAllocation(as_id=hagashi_as_id, examiner_id="VIKING"),
                    ]
                    try:
                        transfer_result = lime_client.transfer_sheets(allocations)
                    except Exception:
                        print(
                            f"ASID: {hagashi_as_id}の移動に失敗しました。再試行します"
                        )
                        lime_client = Client(
                            self.user_id, self.password
                        )  # 401 Unauthorized対策
                        try:
                            transfer_result = lime_client.transfer_sheets(allocations)
                        except Exception:
                            print(f"ASID: {hagashi_as_id}の移動に失敗しました")
                            message = f"team774 → VIKINGの移動に失敗しました。ASID: {hagashi_as_id}"
                            send_error_message(message)
                            continue
                    if not transfer_result[0].transferred:
                        print(f"ASID: {hagashi_as_id}の移動に失敗しました")
                        message = f"team774 → VIKINGの移動に失敗しました。ASID: {hagashi_as_id}"
                        send_error_message(message)
                        continue
        delay_answers_df = pd.concat([delay_answers_df, error_df], ignore_index=True)
        deadline_answers_df = pd.concat(
            [deadline_answers_df, delay_answers_df], ignore_index=True
        )
        return deadline_answers_df, is_over_threshold

    def send_manual_hagashi_message(self, hagashi_answer_df: pd.DataFrame):
        """手動剥がし用のメッセージを作成する"""
        examiner_ids = hagashi_answer_df["id"].tolist()
        mention = "<!channel>"
        if self.is_test:
            mention = "あっとchannel"
        manual_hagashi_message = f"{mention}\n剥がし答案の件数が多すぎるため、自動剥がしを行いません。\nスレッドに剥がし対象答案を記載します。 *LIME等で手動で剥がしてください。*\n"
        if self.is_test:
            channel = SLACK_CH_ID_LEADER_TEST
        else:
            channel = SLACK_CH_ID_LEADER_NOTICE
        slack = Slack(SLACK_TOKEN_LEADER)
        slack_response = slack.chat_postMessage(channel=channel, text=manual_hagashi_message)
        thread_ts = slack_response["ts"]
        time.sleep(1.0)
        manual_hagashi_as_ids_message = ""
        for examiner_id in examiner_ids:
            examiner_df = hagashi_answer_df.query(f'id == "{examiner_id}"')
            as_ids = examiner_df["as_ids"].values[0]
            as_ids = [str(as_id) for as_id in as_ids]
            as_ids_str = ", ".join(as_ids)
            examiner_name = examiner_df["name"].values[0]
            manual_hagashi_as_ids_message += f"{examiner_id} {examiner_name} :\n"
            manual_hagashi_as_ids_message += f">{as_ids_str}\n"
        # 2行毎に分割して送信
        manual_hagashi_message_list = manual_hagashi_as_ids_message.split("\n")
        manual_hagashi_message_list = [
            "\n".join(manual_hagashi_message_list[i : i + 2])
            for i in range(0, len(manual_hagashi_message_list), 2)
        ]
        for message in manual_hagashi_message_list:
            if self.is_test:
                print(message)
            slack.chat_postMessage(channel=channel, text=message, thread_ts=thread_ts)
            time.sleep(1.0) # apiのrate limits対策

    def send_shidai_viking_notice_message(self, shidai_hagashi_answer_df: pd.DataFrame):
        """私大WSにバイキング周知用メッセージを送信し、closing報告チャンネルにも通知する"""
        print("私大WSにバイキング周知用メッセージを送信します")
        message_template_df = self.get_message_template_df(
            sheet_name="バイキング周知用"
        )
        message_template = message_template_df[message_template_df["種別"] == "採点者"][
            "テンプレート"
        ].values[0]
        return_date = self.return_date.strftime("%m月%d日")
        as_ids = []
        for as_id_list in shidai_hagashi_answer_df["as_ids"].tolist():
            as_ids.extend(as_id_list)
        as_ids = list(set(as_ids))
        num_of_answers = len(as_ids)
        as_ids_str = ", ".join(as_ids)
        message_text = message_template.format(
            num_of_answers=num_of_answers, return_date=return_date
        )
        # Slackにメッセージを送信
        if self.is_test:
            print(message_text)
            slack_ch_id = SLACK_CH_ID_SHIDAI_TEST
        else:
            slack_ch_id = SLACK_CH_ID_SHIDAI_NOTICE
        slack = Slack(SLACK_TOKEN_SHIDAI)
        slack.chat_postMessage(channel=slack_ch_id, text=message_text)
        time.sleep(1.0)
        mention = "<!channel>"
        if self.is_test:
            mention = "あっとchannel"
        leader_message = (
            f"{mention} {return_date}のクロージング担当者 または お手隙の方\n"
            f"私大採点者の剥がしが発生しました。\n"
            f"以下の答案をteam774に移動し、緊急答案共有チャンネルで共有しています。\n"
            f"ASID: {as_ids_str}\n"
            f"返信があったら適宜振り分けをお願いします。"
        )
        slack = Slack(SLACK_TOKEN_LEADER)
        if self.is_test:
            print(leader_message)
            slack_ch_id = SLACK_CH_ID_LEADER_TEST
        else:
            slack_ch_id = SLACK_CH_ID_LEADER_NOTICE
        slack.chat_postMessage(channel=slack_ch_id, text=leader_message)
        time.sleep(1.0)

    def send_complete_report(self, deadline_answers_df: pd.DataFrame, mode: str):
        """遅延報告の完了報告を送信する"""
        print("遅延報告の完了報告を送信します")
        if deadline_answers_df.empty:
            message = f"~~~{self.return_date.strftime('%m月%d日')}返却答案 {mode}完了報告~~~\n"
            message += "遅延答案はありませんでした"
            print(message)
            slack = Slack(SLACK_TOKEN_LEADER)
            channel_id = SLACK_CH_ID_LEADER_NOTICE
            if self.is_test:
                channel_id = SLACK_CH_ID_LEADER_TEST
            slack.chat_postMessage(channel=channel_id, text=message)
            return
        # 遅延答案の情報を取得
        delay_answers_df = deadline_answers_df.query('type == "delay"')
        # 特別添削者番号の情報を取得
        special_answers_df = deadline_answers_df.query('type == "special"')
        # バイキング所持者の情報を取得
        viking_answers_df = deadline_answers_df.query('type == "viking"')
        # 二次FB所持者の情報を取得
        second_fb_answers_df = deadline_answers_df.query('type == "2nd_fb"')
        # 問い合わせ待ち添削者の情報を取得
        form_answers_df = deadline_answers_df.query('type == "form"')
        # 代理提出者の情報を取得
        request_answers_df = deadline_answers_df.query('type == "request"')
        # 報告アリ遅延
        reported_delay_answers_df = delay_answers_df.query("is_reported == True")
        # 報告ナシ遅延
        not_reported_delay_answers_df = delay_answers_df.query("is_reported == False")
        # 剥がし答案の情報を取（国公立）
        hagashi_answers_df = deadline_answers_df.query('type == "hagashi"')
        # 剥がし答案の情報を取得（私立）
        shidai_hagashi_answers_df = deadline_answers_df.query(
            'type == "shidai_hagashi"'
        )
        # 剥がし答案の情報を結合
        total_hagashi_answers_df = pd.concat(
            [hagashi_answers_df, shidai_hagashi_answers_df], ignore_index=True
        )
        # 点数未入力答案の情報を取得
        empty_answers_df = deadline_answers_df.query('type == "empty"')
        # 剥がし失敗答案の情報を取得
        error_answers_df = deadline_answers_df.query('type == "error"')

        # 未アップロード答案のASIDのリストを取得
        not_uploaded_answers = []
        for as_ids in reported_delay_answers_df["as_ids"].tolist():
            not_uploaded_answers.extend(as_ids)
        for as_ids in not_reported_delay_answers_df["as_ids"].tolist():
            not_uploaded_answers.extend(as_ids)
        # 取得済みバイキング答案のASIDのリストを取得
        viking_answers = []
        for as_ids in viking_answers_df["as_ids"].tolist():
            viking_answers.extend(as_ids)
            not_uploaded_answers.extend(as_ids)
        # 代理提出待ち答案のASIDのリストを取得
        request_answers = []
        for as_ids in request_answers_df["as_ids"].tolist():
            request_answers.extend(as_ids)
        # 特殊添削者番号答案のASIDのリストを取得
        special_answers = []
        for as_ids in special_answers_df["as_ids"].tolist():
            special_answers.extend(as_ids)
            not_uploaded_answers.extend(as_ids)
        # 剥がし答案のASIDのリストを取得
        total_hagashi_as_ids = []
        for as_ids in total_hagashi_answers_df["as_ids"].tolist():
            total_hagashi_as_ids.extend(as_ids)
            not_uploaded_answers.extend(as_ids)

        # 完了報告文面を作成
        if mode == "夜催促":
            complete_report_text = (
                f"~~~{self.return_date.strftime('%m月%d日')}返却答案 {mode}完了報告~~~\n"
                f"遅延人数：{len(reported_delay_answers_df) + len(not_reported_delay_answers_df)}人"
                f"（報告済{len(reported_delay_answers_df)}人、未報告{len(not_reported_delay_answers_df)}人）\n"
                f"未アップ件数：{len(not_uploaded_answers)}件\n"
                f"取得済バイキング件数：{len(viking_answers)}件\n"
                f"代理提出待ち件数：{len(request_answers)}件\n"
                f"特殊ID答案件数（VIKING等）：{len(special_answers)}件\n"
            )
        elif mode == "夜剥がし" or "朝剥がし":
            total_hagashi_as_ids = []
            for as_ids in total_hagashi_answers_df["as_ids"].tolist():
                total_hagashi_as_ids.extend(as_ids)
            total_hagashi_as_ids = list(set(total_hagashi_as_ids))
            total_empty_as_ids = []
            for as_ids in empty_answers_df["as_ids"].tolist():
                total_empty_as_ids.extend(as_ids)
            total_empty_as_ids = list(set(total_empty_as_ids))
            total_error_as_ids = []
            for as_ids in error_answers_df["as_ids"].tolist():
                total_error_as_ids.extend(as_ids)
            complete_report_text = (
                f"~~~{self.return_date.strftime('%m月%d日')}返却答案 {mode}完了報告~~~\n"
                f"遅延人数：{len(reported_delay_answers_df) + len(not_reported_delay_answers_df)}人"
                f"（報告済{len(reported_delay_answers_df)}人、未報告{len(not_reported_delay_answers_df)}人）\n"
                f"未アップ件数：{len(not_uploaded_answers)}件\n"
                f"取得済バイキング件数：{len(viking_answers)}件\n"
                f"代理提出待ち件数：{len(request_answers)}件\n"
                f"特殊ID答案件数（VIKING等）：{len(special_answers)}件\n"
                f"点数未入力件数：{len(total_empty_as_ids)}件\n"
                f"剥がし人数：{len(total_hagashi_answers_df)}人\n"
                f"剥がし答案件数：{len(total_hagashi_as_ids)}件\n"
                f"剥がし失敗答案件数：{len(total_error_as_ids)}件\n"
            )
        else:
            print("modeが不正です")
            complete_report_text = ""
        complete_report_text += (
            "{summary_total_hagashi}"
            "{summary_not_reported}"
            "{summary_reported}"
            "{summary_no_count}"
            "{summary_request}"
            "{summary_viking}"
            "{summary_special}"
            "{summary_empty}"
            "{summary_error}"
        )
        if self.is_final_approach:
            complete_report_text = f"*!!!!!【FA対応分】!!!!!* \n{complete_report_text}"
        if self.is_shidai_only:
            complete_report_text = (
                f"*!!!!!【私大のみ対象】!!!!!* \n{complete_report_text}"
            )
        # summary文面を作成
        # 無断遅延者の情報を作成
        summary_not_reported = ""
        for examiner_id in not_reported_delay_answers_df["id"].tolist():
            examiner_df = not_reported_delay_answers_df.query(f'id == "{examiner_id}"')
            examiner_name = examiner_df["name"].values[0]
            num_of_answers = len(examiner_df["as_ids"].values[0])
            summary_not_reported += (
                f"{examiner_id} {examiner_name}\t{num_of_answers}件\n"
            )
        if summary_not_reported != "":
            summary_not_reported = (
                f"~~~~~~~~~~~~無断遅延者~~~~~~~~~~~~\n{summary_not_reported}"
            )
        # 予告遅延者の情報を作成
        summary_reported = ""
        for examiner_id in reported_delay_answers_df["id"].tolist():
            examiner_df = reported_delay_answers_df.query(f'id == "{examiner_id}"')
            examiner_name = examiner_df["name"].values[0]
            num_of_answers = len(examiner_df["as_ids"].values[0])
            scheduled_time = examiner_df["submission_time"].values[0]
            summary_reported += (
                f"{examiner_id} {examiner_name}\t{num_of_answers}件：{scheduled_time}\n"
            )
        if summary_reported != "":
            summary_reported = f"~~~~~~~~~~~~予告遅延者~~~~~~~~~~~~\n{summary_reported}"
        # ノーカウント扱い添削者の情報を作成
        summary_no_count = ""
        for examiner_id in second_fb_answers_df["id"].tolist():
            examiner_df = second_fb_answers_df.query(f'id == "{examiner_id}"')
            examiner_name = examiner_df["name"].values[0]
            num_of_answers = len(examiner_df["as_ids"].values[0])
            scheduled_time = examiner_df["submission_time"].values[0]
            reason = "【二次FB待ち】"
            summary_no_count += f"{examiner_id} {examiner_name}\t{num_of_answers}件：{scheduled_time} {reason}\n"
        for examiner_id in form_answers_df["id"].tolist():
            examiner_df = form_answers_df.query(f'id == "{examiner_id}"')
            examiner_name = examiner_df["name"].values[0]
            num_of_answers = len(examiner_df["as_ids"].values[0])
            scheduled_time = examiner_df["submission_time"].values[0]
            reason = "【問い合わせフォーム】"
            summary_no_count += f"{examiner_id} {examiner_name}\t{num_of_answers}件：{scheduled_time} {reason}\n"
        if summary_no_count != "":
            summary_no_count = (
                f"~~~~~~~~~~~~ノーカウント~~~~~~~~~~~~\n{summary_no_count}"
            )
        # 代理提出待ちの情報を作成
        summary_request = ""
        for examiner_id in request_answers_df["id"].tolist():
            examiner_df = request_answers_df.query(f'id == "{examiner_id}"')
            examiner_name = examiner_df["name"].values[0]
            num_of_answers = len(examiner_df["as_ids"].values[0])
            scheduled_time = examiner_df["submission_time"].values[0]
            summary_request += f"{examiner_id} {examiner_name}\t{num_of_answers}件\n"
        if summary_request != "":
            summary_request = f"~~~~~~~~~~~~代理提出待ち~~~~~~~~~~~~\n{summary_request}"
        # バイキング答案所持者の情報を作成
        summary_viking = ""
        for examiner_id in viking_answers_df["id"].tolist():
            examiner_df = viking_answers_df.query(f'id == "{examiner_id}"')
            examiner_name = examiner_df["name"].values[0]
            num_of_answers = len(examiner_df["as_ids"].values[0])
            summary_viking += f"{examiner_id} {examiner_name}\t{num_of_answers}件\n"
        if summary_viking != "":
            summary_viking = (
                f"~~~~~~~~~~~~バイキング答案所持~~~~~~~~~~~~\n{summary_viking}"
            )
        # 特殊ID添削者の情報を作成
        summary_special = ""
        for examiner_id in special_answers_df["id"].tolist():
            examiner_df = special_answers_df.query(f'id == "{examiner_id}"')
            examiner_name = examiner_df["name"].values[0]
            num_of_answers = len(examiner_df["as_ids"].values[0])
            if "VIKING" in examiner_id and "剥がし" in mode:
                summary_special += f"{examiner_id} {examiner_name}\t{num_of_answers}件 + 剥がし{len(total_hagashi_as_ids)}件\n"
            else:
                summary_special += (
                    f"{examiner_id} {examiner_name}\t{num_of_answers}件\n"
                )
        if summary_special != "":
            summary_special = f"~~~~~~~~~~~~特殊ID~~~~~~~~~~~~\n{summary_special}"
        # 剥がし答案所持者の情報を作成
        summary_total_hagashi = ""
        for examiner_id in total_hagashi_answers_df["id"].tolist():
            examiner_df = total_hagashi_answers_df.query(f'id == "{examiner_id}"')
            examiner_name = examiner_df["name"].values[0]
            num_of_answers = len(examiner_df["as_ids"].values[0])
            summary_total_hagashi += (
                f"{examiner_id} {examiner_name}\t{num_of_answers}件\n"
            )
        if summary_total_hagashi != "":
            summary_total_hagashi = (
                f"~~~~~~~~~~~~剥がした添削者~~~~~~~~~~~~\n{summary_total_hagashi}"
            )
        # 点数未入力者の情報を作成
        summary_empty = ""
        for examiner_id in empty_answers_df["id"].tolist():
            examiner_df = empty_answers_df.query(f'id == "{examiner_id}"')
            examiner_name = examiner_df["name"].values[0]
            num_of_answers = len(examiner_df["as_ids"].values[0])
            summary_empty += f"{examiner_id} {examiner_name}\t{num_of_answers}件\n"
        if summary_empty != "":
            summary_empty = f"~~~~~~~~~~~~点数未入力者~~~~~~~~~~~~\n{summary_empty}"
        # エラー発生者の情報を作成
        summary_error = ""
        for examiner_id in error_answers_df["id"].tolist():
            examiner_df = error_answers_df.query(f'id == "{examiner_id}"')
            examiner_name = examiner_df["name"].values[0]
            num_of_answers = len(examiner_df["as_ids"].values[0])
            summary_error += f"{examiner_id} {examiner_name}\t{num_of_answers}件\n"
        if summary_error != "":
            summary_error = f"~~~~~~~~~~~~剥がし失敗者~~~~~~~~~~~~\n{summary_error}"
        complete_report_text = complete_report_text.format(
            summary_not_reported=summary_not_reported,
            summary_reported=summary_reported,
            summary_no_count=summary_no_count,
            summary_request=summary_request,
            summary_viking=summary_viking,
            summary_special=summary_special,
            summary_total_hagashi=summary_total_hagashi,
            summary_empty=summary_empty,
            summary_error=summary_error,
        )
        if self.is_test:
            print(complete_report_text)
        # Slackにメッセージを送信
        # メッセージの改行が50行を超えるとエラーが発生するため、50行ごとに分割して送信する
        complete_report_text = complete_report_text.split("\n")
        complete_report_text = [
            complete_report_text[i : i + 50]
            for i in range(0, len(complete_report_text), 50)
        ]
        if self.is_test:
            channel_id = SLACK_CH_ID_LEADER_TEST
        else:
            channel_id = SLACK_CH_ID_LEADER_NOTICE
        slack = Slack(SLACK_TOKEN_LEADER)
        for text in complete_report_text:
            slack.chat_postMessage(channel=channel_id, text="\n".join(text))
            time.sleep(1.0)

    def manage_deadline_answers(self, mode: str):
        """提出期限に関する処理をまとめて実行する"""
        if mode == "夜催促":
            self.manage_delay_answers()
        elif mode == "夜剥がし" or mode == "朝剥がし":
            self.manage_hagashi_answers(mode)
        else:
            print("modeが不正です")
            exit()


def make_parser():
    parser = argparse.ArgumentParser(description="剥がし催促プログラム")
    parser.add_argument(
        "-m", "--mode", type=str, required=True, help="処理モードを指定する"
    )
    parser.add_argument(
        "-id",
        "--user_id",
        default=None,
        type=str,
        help="管理POS/lime_sdkログイン用の添削者番号",
    )
    parser.add_argument(
        "-pw",
        "--password",
        default=None,
        type=str,
        help="管理POS/lime_sdkログイン用のパスワード",
    )
    parser.add_argument(
        "-c", "--colab", action="store_true", help="コラボで実行する際に指定する"
    )
    parser.add_argument("-t", "--test", action="store_true", help="実行テスト用")
    parser.add_argument(
        "-fa", "--final_approach", action="store_true", help="FA期間中なら指定する"
    )
    parser.add_argument(
        "-so", "--shidai_only", action="store_true", help="私大のみ対象にする"
    )
    opt_args = parser.parse_args()

    if opt_args.colab:
        if not opt_args.user_id:
            opt_args.user_id = input(
                "実行者の添削者番号を入力してください\n例：N0480551\n入力："
            )
        if not opt_args.password:
            opt_args.password = getpass.getpass(
                "LIMEのパスワードを入力してください\n入力："
            )
        print("LIMEログインテストを行います")
        for attempt in range(3):
            print(f"ログイン試行回数：{attempt + 1}")
            try:
                Client(opt_args.user_id, opt_args.password)
                print("ログインに成功しました")
                break
            except Exception:
                if attempt == 2:
                    print("ログインに失敗しました。プログラムを終了します")
                    exit()
                print("ログインに失敗しました")
                opt_args.user_id = input("添削者番号を再入力してください\n入力：")
                opt_args.password = getpass.getpass(
                    "パスワードを再入力してください\n入力："
                )
    else:
        if not opt_args.user_id:
            opt_args.user_id = "N0480551"
        if not opt_args.password:
            opt_args.password = ""

    return opt_args


if __name__ == "__main__":
    args = make_parser()
    deadline_answers_manager = DeadlineAnswersManager(
        args.user_id,
        args.password,
        args.colab,
        args.test,
        args.final_approach,
        args.shidai_only,
    )
    try:
        deadline_answers_manager.manage_deadline_answers(args.mode)
    except Exception:
        # tracebackを取得
        tb = traceback.format_exc()
        print(tb)
        # エラー内容をSlackに通知
        slack = Slack(SLACK_TOKEN_LEADER)
        mention = f"<@{IT_MENTION_USER_ID}>"
        error_message = f"{mention}\n`{tb}`"
        slack.chat_postMessage(channel=SLACK_CH_ID_LEADER_TEST, text=error_message)
